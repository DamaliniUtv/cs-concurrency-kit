<?xml version="1.0" encoding="utf-8"?>
<topic id="2a81f423-ee99-4745-a514-3db4a67dbb00" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->

    <introduction>
      <!-- Uncomment this to generate an outline of the section and sub-section
           titles.  Specify a numeric value as the inner text to limit it to
           a specific number of sub-topics when creating the outline.  Specify
           zero (0) to limit it to top-level sections only.  -->
      <!-- <autoOutline /> -->

      <para>The <markup>
        <b>SpicyPixel.Threading.Unity.dll</b>
      </markup> assembly provides functionality
      to integrate the <codeEntityReference>T:SpicyPixel.Threading.Fiber</codeEntityReference> and Task features of the Concurrency Kit with
      the Unity coroutine scheduler.</para>
    </introduction>

    <!-- Add one or more top-level section elements.  These are collapsible.
         If using <autoOutline />, add an address attribute to identify it
         and specify a title so that it can be jumped to with a hyperlink. -->
    <section address="monobehaviour-extensions">
      <title>MonoBehaviour extensions</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>There are multiple approaches you can take to access the task and
        scheduling features of the Concurrency Kit from within a MonoBehaviour.</para>
      </content>
      <!-- If a section contains a sections element, its content creates
           sub-sections.  These are not collapsible. -->
      <sections>
          <section address="using-concurrentbehaviour">
              <title>Using ConcurrentBehaviour</title>
              <content>
                  <para>The <codeEntityReference>T:SpicyPixel.Threading.ConcurrentBehaviour</codeEntityReference> class
                  extends MonoBehaviour with additional properties to make it easy to access the scheduler associated
                  with the behaviour.
                  </para>
                <code>
<![CDATA[
public class MyBehaviour : ConcurrentBehaviour
{
  // If your code requires Awake(), always override the base
  // because this is where the schedulers are setup to ensure
  // the correct thread is selected.
  override void Awake()
  {
    base.Awake();
    // Do custom logic
  }
  
  void Update()
  {
    taskFactory.StartNew(() => DoWorkOnUnityThread()).
      ContinueWith((t) => DoMoreWorkOnUnityThread(), taskScheduler);
  }
}
]]>
                </code>
              </content>
          </section>
          <section address="managing-scheduler-creation">
              <title>Managing scheduler creation</title>
              <content>
                  <para>If it is not convenient to extend your behaviour from <codeEntityReference>T:SpicyPixel.Threading.ConcurrentBehaviour</codeEntityReference>,
                  you can create factory and scheduler instances by invoking one of the extension methods in <codeEntityReference>T:SpicyPixel.Threading.Tasks.UnityTaskExtensions</codeEntityReference>.
                </para>
                <code>
                  <![CDATA[
public class MyBehaviour : MonoBehaviour
{
  private TaskFactory customTaskFactory;
  
  void Awake()
  {
    customTaskFactory = this.CreateTaskFactory();
  }
  
  void Update()
  {
    customTaskFactory.StartNew(() => DoWorkOnUnityThread()).
      ContinueWith((t) => DoMoreWorkOnUnityThread(), customTaskFactory.Scheduler);
  }
}
]]>
                </code>
              </content>
          </section>
          <section address="shared-factory-instance">
            <title>Shared factory</title>
            <content>
              <para>
                You can use <codeEntityReference>T:SpicyPixel.Threading.Tasks.UnityTaskFactory</codeEntityReference> to access a shared factory instance
                which ultimately relies on the shared <codeEntityReference>T:SpicyPixel.Threading.ConcurrentBehaviour</codeEntityReference> instance.
              </para>
              <code>
                <![CDATA[
public class MyBehaviour : MonoBehaviour
{
  void Update()
  {
    UnityTaskFactory.Default.StartNew(() => DoWorkOnUnityThread()).
      ContinueWith((t) => DoMoreWorkOnUnityThread(), UnityTaskScheduler.Default);
  }
}
]]>
              </code>
            </content>
          </section>
          <section address="unitysynchronizationcontext">
            <title>Synchronization context</title>
            <content>
              <para>
                The <codeEntityReference>T:SpicyPixel.Threading.UnitySynchronizationContext</codeEntityReference> is a convenient way
                to integrate with code which relies on a <codeEntityReference>T:System.Threading.SynchronizationContext</codeEntityReference> 
                or to post operations back to the calling thread in a scheduler agnostic manner.
              </para>
              <code>
                <![CDATA[
public class MyBehaviour : MonoBehaviour
{
  void Awake()
  {
    // Install this once at startup in a single behaviour to
    // initialize the context for the main thread.
    SynchronizationContext.SetSynchronizationContext(
		  UnitySynchronizationContext.SharedInstance);
  }
  
  // This example method might be invoked by something from the Unity thread
  // but which needs to process results on a timer.
  void ProcessResults()
  {
    // Save the current thread's sync context before we enter the timer
    // so we can use it for callback.
    var syncContext = SynchronizationContext.Current;
    
    // Start a timer
    new Timer(TimerCallback, syncContext, TimeSpan.FromSeconds(3), TimeSpan.Zero);
  }
  
  // Do something on a timer thread
  void TimerCallback(object state)
  {
    // Get the sync context for the thread that created
    // the timer. Technically we could have referenced
    // UnitySynchronizationContext.SharedInstance since
    // we know that is the thread we want to send back to,
    // but this is the typical pattern you would use to write
    // scheduler agnostic code.
    var syncContext = state as SynchronizationContext;
   
    // We are running in a timer thread here.
    
    // Now, run something back on the thread that started the timer
    syncContext.Send((moreState) => {
      Debug.Log("Back on the Unity thread");
    }, null);
  }
}
]]>
              </code>
            </content>
          </section>
      </sections>
    </section>

    <relatedTopics>
      <!-- One or more of the following:
           - A local link
           - An external link
           - A code entity reference

      <link xlink:href="Other Topic's ID"/>
      <link xlink:href="Other Topic's ID">Link inner text</link>

      <externalLink>
          <linkText>Link text</linkText>
          <linkAlternateText>Optional alternate link text</linkAlternateText>
          <linkUri>URI</linkUri>
      </externalLink>

      <codeEntityReference>API member ID</codeEntityReference>

      Examples:

      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8270" />
      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8278">Some other topic</link>

      <externalLink>
          <linkText>SHFB on CodePlex</linkText>
          <linkAlternateText>Go to CodePlex</linkAlternateText>
          <linkUri>http://shfb.codeplex.com</linkUri>
      </externalLink>

      <codeEntityReference>T:TestDoc.TestClass</codeEntityReference>
      <codeEntityReference>P:TestDoc.TestClass.SomeProperty</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor(System.String,System.Int32)</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.ToString</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.FirstMethod</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.SecondMethod(System.Int32,System.String)</codeEntityReference>
      -->
    </relatedTopics>
  </developerConceptualDocument>
</topic>
