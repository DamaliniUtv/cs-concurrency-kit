<?xml version="1.0" encoding="utf-8"?>
<topic id="ecb518db-2bfe-4374-a299-a309c51973c4" revisionNumber="1">
  <developerWalkthroughDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->

    <introduction>
      <!-- Uncomment this to generate an outline of the section and sub-section
           titles.  Specify a numeric value as the inner text to limit it to
           a specific number of sub-topics when creating the outline.  Specify
           zero (0) to limit it to top-level sections only.  -->
      <!-- <autoOutline /> -->
      <para>
        A <codeEntityReference>T:SpicyPixel.Threading.Fiber</codeEntityReference> is a lightweight means of scheduling work that enables multiple units 
        of processing to execute concurrently by co-operatively sharing execution time 
        on a single thread. Fibers are also known as "micro-threads" and can be 
        implemented using programming language facilities such as "coroutines".
      </para>
      <para>
        Fibers simplify many concurrency issues generally associated with multithreading 
        because a given fiber has complete control over when it yields execution to another 
        fiber. A fiber does not need to manage resource locking or handle changing data in 
        the same way as a thread does because access to a resource is never preempted by 
        another fiber without co-operation.
      </para>
      <para>
        Fibers can improve performance in certain applications with concurrency requirements. 
        Because many fibers can run on a thread, this can relieve pressure on precious 
        resources in the thread pool and reduce latency.
      </para>
      <para>
        Additionally, some applications have concurrent, interdependent processes that naturally 
        lend themselves to co-operative scheduling which can result in greater efficiency when 
        the application manages the context switch instead of a pre-emptive scheduler.
      </para>
      <para>
        Fibers can also be a convenient way to express a state machine. The master fiber 
        implementing the machine can test state conditions, start new fibers for state actions, 
        yield to an action fiber until it completes, and then handle the transition out of the 
        state and into a new state.
      </para>
    </introduction>

    <!-- <prerequisites><content>Optional prerequisites info</content></prerequisites> -->

    <!-- One or more procedure or section with procedure -->
    <!--<procedure>
      <title>Starting a fiber</title>
      <steps class="ordered">
        <step>
          <content>
            <para>First step</para>
          </content>
        </step>
        <step>
          <content>
            <para>Second step</para>
          </content>
        </step>
      </steps>
      <conclusion>Optional conclusion</conclusion> -->
   <!-- </procedure> -->

    <!-- Optional additional procedure or section with procedure -->
    <section address="starting-a-fiber">
      <title>Starting a fiber</title>
      <content>
        <para>
          A fiber can be created and started on the default scheduler for the thread as follows.
        </para>
        <code language="c#">
          Fiber.StartNew(() => DoTask());
        </code>
        <para>
          It is also possible to more precisely control startup and scheduler options.
        </para>
        <code language="c#">
          var fiber = new Fiber(() => DoTask()); // create the fiber
          fiber.Start(myCustomScheduler); // queue the fiber for execution by a custom scheduler
        </code>
      </content>
    </section>
    <section address="using-coroutines">
      <title>Using coroutines</title>
      <content>
        <para>
          A coroutine is a function that can yield execution to another function and this allows multiple functions to execute concurrently on the same thread by co-operatively yielding execution time.
        </para>
        <para>
          Coroutines must return an IEnumerator type and have one or more yield statements that passes a yield instruction back to the fiber scheduler.
        </para>
        <code language="c#">
<![CDATA[
void Main()
{
	Fiber.StartNew(FadeOutCoroutine());
}

IEnumerator FadeOutCoroutine()
{
	var totalTime = 4f;
	var currentTime = totalTime;
	while(currentTime > 0f)
	{
		setAlpha(currentTime / totalTime); // fade out
		currentTime -= Time.deltaTime;
		yield return FiberInstruction.YieldToAnyFiber;
	}
}
]]>
        </code>
      </content>
    </section>
    <section address="waiting-for-commpletion">
      <title>Waiting for completion</title>
      <content>
        <para>
          One fiber can wait for completion of another by yielding the <codeEntityReference>T:SpicyPixel.Threading.YieldUntilComplete</codeEntityReference> instruction returned by <codeEntityReference>M:SpicyPixel.Threading.Fiber.Start</codeEntityReference>.
        </para>
        <code language="c#">
<![CDATA[
void Main()
{
	Fiber.StartNew(Fiber1());
}

IEnumerator Fiber1()
{
	Console.Out.WriteLine(“Beginning Fiber 1 and waiting for Fiber 2 to complete”);
	yield return Fiber.StartNew(Fiber2());
	Console.Out.WriteLine(“Fiber 2 has completed.);
}

IEnumerator Fiber2()
{
	// Do work
	while(!workDone)
	{
		Process();
		yield return FiberInstruction.YieldToAnyFiber;
	}
}
]]>
        </code>
      </content>
    </section>
    <section address="starting-a-fiber-scheduler">
      <title>Starting a fiber scheduler</title>
      <content>
        <para>
          Fiber coordination and execution is handled by a <codeEntityReference>T:SpicyPixel.Threading.FiberScheduler</codeEntityReference>. The default system scheduler can be started on the running thread as follows.
        </para>
        <code language="c#">
<![CDATA[
void Main()
{
	FiberScheduler.Current.Run(new Fiber(MainFiber()));
}

IEnumerator MainFiber()
{
  // do work
}
]]>
        </code>
      </content>
    </section>
    <section address="starting-a-fiber-scheduler-on-a-new-thread">
      <title>Starting a fiber scheduler on a new thread</title>
      <content>
        <para>
          It is often more convenient to start a fiber scheduler on a new thread. The <codeEntityReference>T:SpicyPixel.Threading.SystemFiberScheduler</codeEntityReference> has convenience methods to create the scheduler on a new thread and return a reference.
        </para>
        <code language="c#">
<![CDATA[
void Main()
{
	var scheduler = SystemFiberScheduler.StartNew(new Fiber(MainFiber()));
}

IEnumerator MainFiber()
{
  // do work
}
]]>
        </code>
      </content>
    </section>
    
    <!-- Optional next steps info
    <nextSteps>
      <content><para>Next steps info goes here</para></content>
    </nextSteps>
    -->

    <relatedTopics>
      <!-- One or more of the following:
           - A local link
           - An external link
           - A code entity reference

      <link xlink:href="Other Topic's ID">Link text</link>
      <externalLink>
          <linkText>Link text</linkText>
          <linkAlternateText>Optional alternate link text</linkAlternateText>
          <linkUri>URI</linkUri>
      </externalLink>
      <codeEntityReference>API member ID</codeEntityReference>

      Examples:

      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8278">Some other topic</link>

      <externalLink>
          <linkText>SHFB on CodePlex</linkText>
          <linkAlternateText>Go to CodePlex</linkAlternateText>
          <linkUri>http://shfb.codeplex.com</linkUri>
      </externalLink>

      <codeEntityReference>T:TestDoc.TestClass</codeEntityReference>
      <codeEntityReference>P:TestDoc.TestClass.SomeProperty</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor(System.String,System.Int32)</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.ToString</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.FirstMethod</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.SecondMethod(System.Int32,System.String)</codeEntityReference>
      -->
    </relatedTopics>
  </developerWalkthroughDocument>
</topic>
